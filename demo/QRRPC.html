<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div>
    <h3>select role</h3>
    <input type="radio" id="roleController" name="role" value="controller">
    <label for="roleController">controller</label>
    <input type="radio" id="roleControlled" name="role" value="controlled">
    <label for="roleControlled">controlled</label>
  </div>

  <video id="cameraVideo" width="400" height="300"></video>
  <canvas id="qrOutput"></canvas>

  <script type="module">
    // 목표: 'hello qrcode!' -> 'hello qrcode too!' 전송하기

    import * as Comlink from 'https://jspm.dev/comlink'
    import QRCode from 'https://jspm.dev/qrcode'
    import { JSONRPCServerAndClient, JSONRPCServer, JSONRPCClient } from 'https://jspm.dev/json-rpc-2.0'
    import Queue from '../js/util/Queue.js'
    import Mitt from '../js/util/Mitt.js'
    import once from '../js/util/once.js'

    // QR 리더
    // QRCode를 인식하고 새로운 메시지가 들어오면 'message' 이벤트 발생
    // video width, height 설정 필수

    let role = 'controller'

    class QRReader extends Mitt {
      constructor (videoElem) {
        super()
        this.worker = Comlink.wrap(
          new Worker(new URL('./QRSignaler-worker.js', import.meta.url), { type: 'module' })
        )
        this.lastMsg = undefined
        this.videoElem = videoElem
        this.ctx = document.createElement('canvas').getContext('2d')
        this.ctx.canvas.width = this.videoElem.width
        this.ctx.canvas.height = this.videoElem.height

        this.start()
      }

      async start() {
        await this.worker.init()
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            aspectRatio: 1.3333333333,
            frameRate: 60,
            facingMode: 'user',
            focusMode: 'continuous'
          }
        })

        this.videoElem.srcObject = stream
        this.videoElem.play()

        requestAnimationFrame(() => this.detect())
      }

      async detect () {
        try {
          this.ctx.drawImage(this.videoElem, 0, 0)
          const imageData = this.ctx.getImageData(0, 0, this.videoElem.width, this.videoElem.height)
          const msgs = await this.worker.detectQR(Comlink.transfer(imageData))

          const msg = msgs.filter(m => m.role !== role)[0] 
          if (msg !== undefined && msg !== this.lastMsg) {
            this.lastMsg = msg

            const parsed = JSON.parse(msg)
            this.emit('read', parsed)
          } 
        } finally {
          requestAnimationFrame(() => this.detect())
        }
      }
    }

    // QR 라이터
    async function writeQR (payload) {
      const serialized = JSON.stringify(payload)
      await QRCode.toCanvas(document.querySelector('#qrOutput'), serialized)
    }

    // rpc 관련
    const reader = new QRReader(document.querySelector('#cameraVideo'))
    const msgQueue = new Queue()
    const rpcSocket = new JSONRPCServerAndClient(
      new JSONRPCServer(),
      new JSONRPCClient(async data => {
        console.log('sending', data)
        await writeQR({ role, ...data })
      })
    )

    // controlled 일 경우 qr로 response 돌려주기
    reader.on('read', data => {
      rpcSocket.receiveAndSend(data)
    })

    rpcSocket.addMethod('next', async () => {
      if (msgQueue.size > 0) {
        return msgQueue.pop()
      } else {
        return null
      }
    })

    // 테스트: 속도 측정용
    // 1부터 증가시키며 계속 다음 요청
    document.querySelector('#roleController').addEventListener('click', async () => {
      role = 'controller'
      
      performance.mark('transactionStart')
      for (let i = 0; i < 1000; i++) {
        await rpcSocket.request('next')
      }
      performance.mark('transactionEnd')
      console.log(performance.measure('transaction', 'transactionStart', 'transactionEnd'))
    }, { once: true })

    document.querySelector('#roleControlled').addEventListener('click', async () => {
      role = 'controlled'
      for (let i = 0; i < 1000; i++) {
        msgQueue.push(i)
      }
    }, { once: true })
  </script>
</body>
</html>