<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <video id="cameraVideo" width="400" height="300"></video>
  <canvas id="qrOutput"></canvas>

  <script type="module">
    // 목표: 'hello qrcode!' -> 'hello qrcode too!' 전송하기
    // 확인 메시지: 일단은 단독으로 received + id로, 언젠가는 queue된 메시지랑 같이 전송

    import * as Comlink from 'https://jspm.dev/comlink'
    import QRCode from 'https://jspm.dev/qrcode'
    import Queue from '../js/util/Queue.js'
    import Mitt from '../js/util/Mitt.js'
    import once from '../js/util/once.js'

    // QR 리더
    // QRCode를 인식하고 새로운 메시지가 들어오면 'message' 이벤트 발생
    // video width, height 설정 필수
    class QRReader extends Mitt {
      constructor (videoElem) {
        super()
        this.worker = Comlink.wrap(
          new Worker(new URL('./QRSignaler-worker.js', import.meta.url), { type: 'module' })
        )
        this.lastMsg = undefined
        this.videoElem = videoElem
        this.ctx = document.createElement('canvas').getContext('2d')
        this.ctx.canvas.width = this.videoElem.width
        this.ctx.canvas.height = this.videoElem.height

        this.start()
      }

      async start() {
        await this.worker.init()
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            aspectRatio: 1.3333333333,
            frameRate: 60,
            facingMode: 'user',
            focusMode: 'continuous'
          }
        })

        this.videoElem.srcObject = stream
        this.videoElem.play()

        requestAnimationFrame(() => this.detect())
      }

      async detect () {
        try {
          this.ctx.drawImage(this.videoElem, 0, 0)
          const imageData = this.ctx.getImageData(0, 0, this.videoElem.width, this.videoElem.height)
          const msg = await this.worker.detectQR(Comlink.transfer(imageData))

          if (msg !== undefined && msg !== this.lastMsg) {
            this.lastMsg = msg

            const parsed = JSON.parse(msg)
            this.emit('read', parsed)
          } 
        } finally {
          requestAnimationFrame(() => this.detect())
        }
      }
    }

    // QR 라이터
    async function writeQR (payload) {
      const serialized = JSON.stringify(payload)
      await QRCode.toCanvas(document.querySelector('#qrOutput'), serialized)
    }

    // 이벤트 루프
    // verificationQueue와 MsgQueue에 있는 내용을 합쳐 전송할 메시지 생성
    // verify할 메시지들의 id를 가지고 있음
    const verificationCallbacks = new Map()
    const verificationQueue = new Queue()
    // 보낼 메시지들
    const msgQueue = new Queue()
    async function eventLoop () {
      while (true) {
        const payload = {}
        
        if (verificationQueue.size > 0) {
          payload.verification = verificationQueue.pop()
        }

        if (msgQueue.size > 0) {
          const msg = msgQueue.pop()
          payload.id = msg.id
          payload.msg = msg.msg
        }

        if (!payload.verification && !payload.msg) {
          // 메시지가 없으므로 둘 중 하나가 들어올때까지 대기
          await Promise.any([
            once(msgQueue, 'push'), 
            once(verificationQueue, 'push')
          ])
          continue
        }

        // payload 전송
        await writeQR(payload)
        if (payload.id) {
          
        }
      }
    }

    // 메인
    // key: id, value: resolve()
    const emitter = new Mitt()
    const callbacks = new Map()
    let id = 0
    function send (msg) {
      return new Promise(resolve => {
        const msgID = id++

        if (msgID === 0) eventLoop()

        callbacks.set(msgID, resolve)
        msgQueue.push({
          id: msgID,
          msg
        })
      })
    }

    const reader = new QRReader(document.querySelector('#cameraVideo'))
    reader.on('read', payload => {
      if (payload.verification) {
        const verifiedID = payload.verification
        const resolve = callbacks.get(verifiedID)
        resolve()
      }

      if (payload.msg) {
        emitter.emit('message', payload.msg)
        // verification enqueue
        verificationQueue.push(payload.id)
      }
    })

    // 작동시키기
    async function main () {
      emitter.on('message', msg => {
        console.log('message received', msg)
      })
      
      await send('hello world!')
      await send('hello world again!')
    }
    main()
  </script>
</body>
</html>